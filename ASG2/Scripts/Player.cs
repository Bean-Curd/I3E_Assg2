/*
 * Author: Ashley Goh Yu Ting
 * Date: 05/06/2023
 * Description: I3E/STLD Assignment 2 - Player
 */

using System.Collections;
using System.Collections.Generic;
using UnityEngine;
using UnityEngine.InputSystem; //For movement


public class Player : MonoBehaviour
{
    /// <summary>
    /// New vector with (0,0,0), for WASD movement
    /// </summary>
    Vector3 moveData = Vector3.zero;

    /// <summary>
    /// Movement speed
    /// </summary>
    public float moveSpeed = 0.11f;

    /// <summary>
    /// New vextor for mouse/camera movement
    /// </summary>
    Vector3 rotationInput = Vector3.zero;

    /// <summary>
    /// Rotation speed
    /// </summary>
    public float rotationSpeed = 0.25f;

    /// <summary>
    /// Is player trying to jump
    /// </summary>
    bool jump;

    /// <summary>
    /// Check if player is on the floor -> Prevents double jumping
    /// </summary>
    bool onFloor;

    /// <summary>
    /// Choose the camera for the head so it can rotate the camera instead of the whole body
    /// </summary>
    public Transform head;

    /// <summary>
    /// To set as main camera
    /// </summary>
    Camera cam;

    public static Player instance;

    private void Awake()
    {
        instance = this;
        DontDestroyOnLoad(gameObject);
    }


    // Start is called before the first frame update
    void Start()
    {
        cam = GameObject.FindGameObjectWithTag("MainCamera").GetComponent<Camera>();
    }

    /// <summary>
    /// Triggers when WASD pressed -> Retrieving the input
    /// </summary>
    /// <param name="value"></param>
    void OnMove(InputValue value)
    {
        moveData = value.Get<Vector2>(); //WASD value (W=1,S=-1,A=-1,D=1) -> Generated by Unity
    }

    /// <summary>
    /// For mouse/camera movement
    /// </summary>
    /// <param name="value"></param>
    void OnLook(InputValue value)
    {
        rotationInput.y = value.Get<Vector2>().x; //For left right movement
        rotationInput.x = -value.Get<Vector2>().y; //For up down movement
    }

    /// <summary>
    /// So player can jump
    /// </summary>
    void OnSpaceKey()
    {
        if (onFloor) //If player is on the floor, can jump 
        {
            jump = true;
        }
    }

    void OnFire()
    {
        //ASG2_HealthBar.instance.Damage(1000);
    }

    /// <summary>
    /// What happens when you enter an object
    /// </summary>
    /// <param name="collision"></param>
    private void OnCollisionEnter(Collision collision)
    {
        //Debug.Log(gameObject.name + " Enter " + collision.gameObject.name);
    }

    /// <summary>
    /// What happens when player is on an object
    /// </summary>
    void OnCollisionStay()
    {
        onFloor = true; //Confirm the player is on the floor 
    }

    /// <summary>
    /// What happens when you exit an object
    /// </summary>
    /// <param name="collision"></param>
    private void OnCollisionExit(Collision collision)
    {
        //Debug.Log(gameObject.name + " Exit " + collision.gameObject.name);

        onFloor = false; //Once player is off an object they are no longer touching floor
    }

    public float InteractionDistance = 3f;

    // Update is called once per frame
    void Update()
    {
        if (jump && onFloor) //If player is trying to jump and is on the floor
        {
            GetComponent<Rigidbody>().AddForce(new Vector3(0, 5, 0), ForceMode.Impulse);
            onFloor = false; //Prevents player from jumping immediately after
            jump = false; //Resets jump
        }

        if (Input.GetKey(KeyCode.LeftShift)) //If left shift is pressed, decrease energy bar
        {
            ASG2_EnergyBar.instance.Sprint(20);
        }

        if (Input.GetKeyUp(KeyCode.LeftShift)) //If left shift is lifted, reset movement speed
        {
            moveSpeed = 0.11f;
        }

        if (Input.GetMouseButtonDown(0)) //If left clicking an interactible object -> perform an action
        {
            /// <summary>
            /// Ray sent on left click
            /// </summary>
            Ray ray = cam.ScreenPointToRay(Input.mousePosition);

            if (Physics.Raycast(ray, out RaycastHit hitInfo))
            {
                if (hitInfo.collider.gameObject.GetComponent<Interactible>() != null) //If object is interactible
                {
                    Destroy(hitInfo.collider.gameObject);
                }
            }
        }

        /*if (Physics.Raycast(transform.position, transform.forward, out RaycastHit hit, InteractionDistance))
        {        

            if (hit.collider.tag == "Collectible")
            {
                if (interact == true)
                {
                    Destroy(hit.transform.gameObject);
                    interact = false;
                }
            }
        }*/

        /// <summary>
        /// Turning the input into movement -> forward/back movement
        /// </summary>
        Vector3 forwardMove = transform.forward; //Vector3(0,0,1)

        /// <summary>
        /// Turning the input into movement -> left/right movement
        /// </summary>
        Vector3 rightMove = transform.right; //Vector3(1,0,0)

        /// <summary>
        /// For the player to move
        /// </summary>
        GetComponent<Rigidbody>().MovePosition(transform.position + (forwardMove * moveData.y
        + rightMove * moveData.x) * moveSpeed);

        /// <summary>
        /// For the player to rotate
        /// </summary>
        transform.rotation = Quaternion.Euler(transform.rotation.eulerAngles + new Vector3(0, rotationInput.y) * rotationSpeed);

        /// <summary>
        /// Setting limits so the camera can rotate like how a head would
        /// </summary>
        var rot = head.rotation.eulerAngles + new Vector3(rotationInput.x, 0) * rotationSpeed; //For camera to rotate 

        // Setting limits so the camera can rotate like how a head would
        while (rot.x > 180f)
        {
            rot.x -= 360f;
        }

        while (rot.x < -180f)
        {
            rot.x += 360f;
        }

        if (rot.x > 60f)
        {
            rot.x = 60f;
        }

        if (rot.x < -60f)
        {
            rot.x = -60f;
        }

        /// <summary>
        /// Applying the limits to the head rotation
        /// </summary>
        head.rotation = Quaternion.Euler(rot);
    }
}
